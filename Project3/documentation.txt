Diana Kocsis

First I read in the file "cars.txt" and split up each line to obtain the attributes of each car. I then inserted each car that was created into 2 heaps: a price heap that stores cars in ascending order by price and a mileage heap that stores the cars in ascending order by mileage. The insert method in MinPQ.java ensures that the min heap property is maintained for whatever heap we are working on at the time. This is important for when we want to retrieve the lowest price car and lowest mileage car. The runtime for inserting the cars into the heap is at most log(n) where n is the amount of cars in the heap. This is because we might have to perform 1 swap per level of the complete binary search tree. While inserting the cars into the heap, I also was building an 2 R-way tries (one for price and one for mileage) which will come in handy when I need to update a car. I used an R-way trie to store the car's VIN number and its index in its heap. I used an R-way trie since the VIN numbers are 17 characters long and normally do not have many prefixes. This is a great approach since R-way tries allow for indexing, which will be extremely helpful later on in the project. While the runtime for an R-way trie is theta w, the large use of memory is a downside, as it is wR + n. Finally, I added each car to the separate chaining hash table. This will hash each car's make and model and put each type of car into its own linked list. This is very useful for when the user asks to retrieve the lowest price or mileage car by Make and Model. The runtime for inserting into this is worst case theta n where n is the amount of cars. (This will occur if all of the cars are the same make and model, i.e. they are all in the same linked list). I created the hash table size to be 101 since it is a large prime number and hopefully each make+model will match to its own index. However, there might be a wastage of space if some of the parts of the hash table are never used. However, I believe it is the best approach since it groups the cars in a clean manner.

Next, if the user enters 2, he/she will enter the VIN number of the car that will be updated. By knowing this VIN number, the program can easily index into the R-way trie to find the car's index in the heap. Once knowing this, the car can be grabbed from the heap and its updated price, color, or mileage can be set by using the Car class. Then the heap, trie, and hash table can be updated accordingly. 

The same approach is used for the remove method. 

For the lowest price and lowest mileage methods, the min method is called which returns the car at the first position in the heap (the min). 

Lastly, if the user enters a 6 or a 7, the make+model is hashed in order to find the specific list of where it is stored in the hash table. I created a new heap to store all of the cars in the linked list, but only if the make+model is the same as the make+model the user inputted. (Since the method hashCode() does not mean that all different objects are hashed to a different index.) By putting these into a heap, the min method can be called. 

The program will continue to loop through until the user enters 8 which terminates the program. 
